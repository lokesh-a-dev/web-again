<!DOCTYPE html>
<html>
<head>
  <title>Minimal WebRTC</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background: #0b0f19;
      color: white;
    }

    #join {
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
    }

    #room {
      display: none;
      height: 100vh;
      flex-direction: column;
    }

    #videos {
      flex: 1;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 10px;
      padding: 10px;
    }

    video {
      width: 100%;
      background: black;
      border-radius: 8px;
    }

    button {
      padding: 8px 16px;
      background: #1f2937;
      color: white;
      border: none;
      cursor: pointer;
    }

    button:hover {
      background: #7f1d1d;
    }

    #controls {
      padding: 10px;
      text-align: center;
      background: #111827;
    }
  </style>
</head>
<body>

<div id="join">
  <input id="roomId" placeholder="Room ID" />
  <button onclick="joinRoom()">Join</button>
</div>

<div id="room">
  <div id="videos"></div>
  <div id="controls">
    <button onclick="endCall()">End Call</button>
  </div>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
const socket = io();
const peers = {};
let localStream;

/* JOIN ROOM */

async function joinRoom() {
  const roomId = document.getElementById("roomId").value;
  if (!roomId) return;

  document.getElementById("join").style.display = "none";
  document.getElementById("room").style.display = "flex";

  localStream = await navigator.mediaDevices.getUserMedia({
    video: true,
    audio: true
  });

  addVideo(localStream, "local");

  socket.emit("join-room", roomId);
}

/* SOCKET EVENTS */

socket.on("existing-users", users => {
  users.forEach(id => createPeer(id, true));
});

socket.on("new-user", id => {
  createPeer(id, false);
});

socket.on("offer", async ({ offer, from }) => {
  if (!peers[from]) createPeer(from, false);

  await peers[from].setRemoteDescription(offer);
  const answer = await peers[from].createAnswer();
  await peers[from].setLocalDescription(answer);

  socket.emit("answer", { answer, to: from });
});

socket.on("answer", async ({ answer, from }) => {
  await peers[from].setRemoteDescription(answer);
});

socket.on("ice-candidate", async ({ candidate, from }) => {
  if (peers[from]) {
    await peers[from].addIceCandidate(candidate);
  }
});

socket.on("user-left", id => {
  if (peers[id]) {
    peers[id].close();
    delete peers[id];
    document.getElementById(id)?.remove();
  }
});

/* PEER CREATION */

function createPeer(id, initiator) {

  if (peers[id]) return;

  const pc = new RTCPeerConnection({
    iceServers: [
      { urls: "stun:stun.l.google.com:19302" }
    ]
  });

  peers[id] = pc;

  localStream.getTracks().forEach(track =>
    pc.addTrack(track, localStream)
  );

  pc.ontrack = e => addVideo(e.streams[0], id);

  pc.onicecandidate = e => {
    if (e.candidate) {
      socket.emit("ice-candidate", {
        candidate: e.candidate,
        to: id
      });
    }
  };

  if (initiator) {
    pc.createOffer()
      .then(o => pc.setLocalDescription(o))
      .then(() => {
        socket.emit("offer", {
          offer: pc.localDescription,
          to: id
        });
      });
  }
}

/* VIDEO HANDLING */

function addVideo(stream, id) {
  if (document.getElementById(id)) return;

  const video = document.createElement("video");
  video.id = id;
  video.srcObject = stream;
  video.autoplay = true;
  video.playsInline = true;

  document.getElementById("videos").appendChild(video);
}

/* END CALL */

function endCall() {
  Object.values(peers).forEach(pc => pc.close());

  for (let id in peers) delete peers[id];

  if (localStream) {
    localStream.getTracks().forEach(track => track.stop());
  }

  document.getElementById("videos").innerHTML = "";
  document.getElementById("room").style.display = "none";
  document.getElementById("join").style.display = "flex";
}
</script>

</body>
</html>